// lovelace card imports.
import { HomeAssistant } from 'custom-card-helpers';
import { ServiceCallRequest } from 'custom-card-helpers/dist/types';
import {
  mdiGoogleChrome,
  mdiMicrosoftEdge,
  mdiSpeaker,
  mdiWeb,
} from '@mdi/js';

// our imports.
import { DOMAIN_SPOTIFYPLUS } from '../constants';
import { ServiceCallResponse } from '../types/service-call-response';
import { MediaPlayer } from '../model/media-player';
import { getMdiIconImageUrl } from '../utils/media-browser-utils';
import { SearchMediaTypes } from '../types/search-media-types';
import { IAlbum } from '../types/spotifyplus/album';
import { IAlbumPageSaved } from '../types/spotifyplus/album-page-saved';
import { IAlbumPageSimplified } from '../types/spotifyplus/album-page-simplified';
import { IAlbumSimplified } from '../types/spotifyplus/album-simplified';
import { IArtist } from '../types/spotifyplus/artist';
import { IArtistInfo } from '../types/spotifyplus/artist-info';
import { IArtistPage } from '../types/spotifyplus/artist-page';
import { IAudiobookPageSimplified } from '../types/spotifyplus/audiobook-page-simplified';
import { IAudiobookSimplified } from '../types/spotifyplus/audiobook-simplified';
import { IChapter } from '../types/spotifyplus/chapter';
import { IChapterPageSimplified } from '../types/spotifyplus/chapter-page-simplified';
import { IEpisode } from '../types/spotifyplus/episode';
import { IEpisodePageSaved } from '../types/spotifyplus/episode-page-saved';
import { IEpisodePageSimplified } from '../types/spotifyplus/episode-page-simplified';
import { IEpisodeSimplified } from '../types/spotifyplus/episode-simplified';
import { IPlayerQueueInfo } from '../types/spotifyplus/player-queue-info';
import { IPlaylistPage } from '../types/spotifyplus/playlist-page';
import { IPlaylistPageSimplified } from '../types/spotifyplus/playlist-page-simplified';
import { IPlaylistSimplified } from '../types/spotifyplus/playlist-simplified';
import { IPlayHistoryPage } from '../types/spotifyplus/play-history-page';
import { IShowPageSaved } from '../types/spotifyplus/show-page-saved';
import { IShowPageSimplified } from '../types/spotifyplus/show-page-simplified';
import { IShowSimplified } from '../types/spotifyplus/show-simplified';
import { ISpotifyConnectDevices } from '../types/spotifyplus/spotify-connect-devices';
import { ITrack } from '../types/spotifyplus/track';
import { ITrackPage } from '../types/spotifyplus/track-page';
import { ITrackPageSaved } from '../types/spotifyplus/track-page-saved';
import { ITrackPageSimplified } from '../types/spotifyplus/track-page-simplified';

// debug logging.
import Debug from 'debug/src/browser.js';
import { DEBUG_APP_NAME } from '../constants';
const debuglog = Debug(DEBUG_APP_NAME + ":spotifyplus-service");


/** SpotifyPlus custom services provider class. */
export class SpotifyPlusService {

  /** Home Assistant instance. */
  private readonly hass: HomeAssistant;

  /** Custom card instance. */
  public readonly card: Element;


  /**
   * Initializes a new instance of the class.
   * 
   * @param hass HomeAssistant instance.
   * @param card Parent custom card instance.
   * @param section Currently selected section of the card.
   */
  constructor(hass: HomeAssistant, card: Element) {

    // initialize storage.
    this.hass = hass;
    this.card = card;
  }


  /**
   * Calls the specified SpotifyPlus service, passing it the specified parameters.
   * 
   * @param serviceRequest Service request instance that contains the service to call and its parameters.
  */
  public async CallService(
    serviceRequest: ServiceCallRequest,
  ): Promise<void> {

    try {

      if (debuglog.enabled) {
        debuglog("%cCallService - Calling service %s (no response)\n%s",
          "color: orange",
          JSON.stringify(serviceRequest.service),
          JSON.stringify(serviceRequest, null, 2)
        );
      }

      // call the service.
      await this.hass.callService(
        serviceRequest.domain,
        serviceRequest.service,
        serviceRequest.serviceData,
        serviceRequest.target,
      )

    }
    finally {
    }
  }


  /**
   * Calls the specified SpotifyPlus service and returns response data that is generated by the
   * service.  The service is called via a script, as there is currently no way to return service 
   * response data from a call to "hass.callService()" (as of 2024/04/26).
   * 
   * @param serviceRequest Service request instance that contains the service to call and its parameters.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CallServiceWithResponse(
    serviceRequest: ServiceCallRequest,
  ): Promise<string> {

    try {

      if (debuglog.enabled) {
        debuglog("%cCallServiceWithResponse - Calling service %s (with response)\n%s",
          "color: orange",
          JSON.stringify(serviceRequest.service),
          JSON.stringify(serviceRequest, null, 2)
        );
      }

      // call the service as a script.
      const serviceResponse = await this.hass.connection.sendMessagePromise<ServiceCallResponse>({
        type: "execute_script",
        sequence: [{
          "service": serviceRequest.domain + "." + serviceRequest.service,
          "data": serviceRequest.serviceData,
          "target": serviceRequest.target,
          "response_variable": "service_result"
        },
        {
          "stop": "done",
          "response_variable": "service_result"
        }]
      });

      //console.log("CallServiceWithResponse (spotifyplus-service) - Service Response:\n%s",
      //  JSON.stringify(serviceResponse.response)
      //);

      // return the service response data or an empty dictionary if no response data was generated.
      return JSON.stringify(serviceResponse.response)

    }
    finally {
    }
  }


  /**
   * Returns the "result" portion of a SpotifyPlus service response that contains
   * the "user_profile" and "result" keys.
   * 
   * @param jsonString JSON response string
  */
  private _GetJsonStringResult(jsonString: string): string {

    let result: string = '';
    const RESULT_KEY: string = '"result":'
    const RESULT_KEY_LEN: number = RESULT_KEY.length;

    // does service response containe a "result" key?
    const idx: number = jsonString.indexOf(RESULT_KEY);
    const jsonStringLen: number = jsonString.length;

    //console.log("%c _GetJsonStringResult (spotifyplus-service)\n idx = %s\n length = %s",
    //  "color: gold;",
    //  JSON.stringify(idx),
    //  JSON.stringify(jsonStringLen)
    //);

    if (idx > -1) {

      // return the "result" key portion of the response.
      result = jsonString.substring(idx + RESULT_KEY_LEN, jsonStringLen - 1);
    }

    //console.log("%c _GetJsonStringResult (spotifyplus-service) result string:\n%s",
    //  "color: gold;",
    //  JSON.stringify(result),
    //);

    return result;
  }


  ///**
  // * Returns the "user_profile" portion of a SpotifyPlus service response that contains
  // * the "user_profile" and "result" keys.
  // *
  // * @param jsonString JSON response string
  //*/
  //private _GetJsonStringUserProfile(jsonString: string): string {

  //  let result: string = '';
  //  const RESULT_KEY: string = '"result":{'
  //  const USERPROFILE_KEY: string = '"user_profile":{'
  //  const USERPROFILE_KEY_LEN: number = USERPROFILE_KEY.length;

  //  // does service response contain a "result" key?
  //  const idx: number = jsonString.indexOf(USERPROFILE_KEY);
  //  const idxEnd: number = jsonString.indexOf(RESULT_KEY);
  //  if (idx > -1) {

  //    // return the "user_profile" key portion of the response, surrounded by the
  //    // opening and closing brackets to simulate a complete JSON response.
  //    result = '{' + jsonString.substring(1 + USERPROFILE_KEY_LEN, idxEnd - 2) + '}';
  //  }

  //  //console.log("%cspotifyplus-service._GetJsonStringUserProfile()\n result string:\n%s", "color: gold;", result);
  //  return result;
  //}


  /**
   * Check if one or more albums (or the currently playing album) exists in the current 
   * user's 'Your Library' favorites.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the albums.  If null, the currently playing track album uri id value is used.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckAlbumFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_album_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Check if one or more artists (or the currently playing artist) exists in the current 
   * user's 'Your Library' favorites.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the artists.  If null, the currently playing track artist uri id value is used.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckArtistsFollowing(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_artists_following',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Check if one or more audiobooks (or the currently playing audiobook) exists in the current 
   * user's 'Your Library' favorites.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the audiobooks.  If null, the currently playing audiobook uri id value is used.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckAudiobookFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_audiobook_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Check if one or more episodes (or the currently playing episode) exists in the current 
   * user's 'Your Library' favorites.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the episodes.  If null, the currently playing episode uri id value is used.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckEpisodeFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_episode_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Check to see if the current user is following a specified playlist.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param playlist_id The Spotify ID of the playlist (e.g. `3cEYpjA9oz9GiPac4AsH4n`).
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckPlaylistFollowers(
    entity_id: string,
    playlist_id: string,
    user_ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        playlist_id: playlist_id,
      };

      // update service data parameters (with optional parameters).
      if (user_ids)
        serviceData['user_ids'] = user_ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_playlist_followers',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Check if one or more shows (or the currently playing show) exists in the current 
   * user's 'Your Library' favorites.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the shows.  If null, the currently playing show uri id value is used.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckShowFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_show_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Check if one or more tracks (or the currently playing track) exists in the current 
   * user's 'Your Library' favorites.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the tracks.  If null, the currently playing track uri id value is used.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CheckTrackFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<Record<string, boolean>> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'check_track_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult);
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Add the current user as a follower of one or more artists.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the artists.  If null, the currently playing track artist uri id value is used.
  */
  public async FollowArtists(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'follow_artists',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Add the current user as a follower of a playlist.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param playlist_id The Spotify ID of the playlist (e.g. `3cEYpjA9oz9GiPac4AsH4n`). If null, the currently playing playlist uri id value is used.
   * @param public If true the playlist will be included in user's public playlists, if false it will remain private. Default is True. 
  */
  public async FollowPlaylist(
    entity_id: string,
    playlist_id: string | undefined | null = null,
    is_public: boolean | undefined | null = true,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (playlist_id)
        serviceData['playlist_id'] = playlist_id;
      if (is_public)
        serviceData['public'] = is_public;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'follow_playlist',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information for a single album identified by its unique Spotify ID.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param album_id The Spotify ID of the album.  If null, the currently playing album uri id value is used. Example `1kWUud3vY5ij5r62zxpTRy`.
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A `IAlbum` object that contains the album details.
  */
  public async GetAlbum(
    entity_id: string,
    album_id: string | undefined | null = null,
    market: string | undefined | null = null,
    trimResults: boolean = true,
  ): Promise<IAlbum> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (album_id)
        serviceData['album_id'] = album_id;
      if (market)
        serviceData['market'] = market;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_album',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IAlbum;

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.tracks != null)) {
          responseObj.available_markets = [];
          responseObj.images = [];
          responseObj.tracks.items.forEach(item => {
            item.available_markets = [];
          })
        }
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the albums saved in the current Spotify user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A AlbumPageSaved object.
  */
  public async GetAlbumFavorites(
    entity_id: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<IAlbumPageSaved> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_album_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IAlbumPageSaved;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      //throw new Error("Test exception thrown in GetAlbumFavorites method.");   // TEST TODO REMOVEME

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.album.images = [];
            item.album.available_markets = [];
            if (item.album.tracks) {
              item.album.tracks = JSON.parse("{ }") as ITrackPageSimplified;
            }
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about an album's tracks.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param album_id The Spotify ID of the album (e.g. `6vc9OTcyd3hyzabCmsdnwE`). If null, the currently playing album uri id value is used; a Spotify Free or Premium account is required to correctly read the currently playing context.
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A TrackPageSimplified object.
  */
  public async GetAlbumTracks(
    entity_id: string,
    album_id: string | null = null,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<ITrackPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (album_id)
        serviceData['album_id'] = album_id;
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_album_tracks',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as ITrackPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.available_markets = [];
          })
        }
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about an artist's albums.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param artist_id The Spotify ID of the artist.  If omitted, the currently playing artist uri id value is used.
   * @param include_groups A comma-separated list of keywords that will be used to filter the response.  If not supplied, only `album` types will be returned. Valid values are `album`, `single`, `appears_on`, `compilation`.
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A AlbumPageSimplified object.
  */
  public async GetArtistAlbums(
    entity_id: string,
    artist_id: string | undefined | null = null,
    include_groups: string | undefined | null = null,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<IAlbumPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (artist_id)
        serviceData['artist_id'] = artist_id;
      if (include_groups)
        serviceData['include_groups'] = include_groups;
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_artist_albums',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IAlbumPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.images = [];
            item.available_markets = []
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get artist about information from the Spotify Artist Biography page for the specified Spotify artist ID.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param artist_id The Spotify ID of the artist.  If omitted, the currently playing artist uri id value is used.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IArtistInfo object.
  */
  public async GetArtistInfo(
    entity_id: string,
    artist_id: string | undefined | null = null,
    trimResults: boolean = true,
  ): Promise<IArtistInfo> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (artist_id)
        serviceData['artist_id'] = artist_id;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_artist_info',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IArtistInfo;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if (responseObj != null) {
          // nothing to trim at this point.
        }
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get the current user's followed artists.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param after The last artist ID retrieved from the previous request, or null for the first request.  Example: `6APm8EjxOHSYM5B4i3vT3q`.
   * @param limit The maximum number of items to return in a page of items when manual paging is used.  Default: 20, Range: 1 to 50.  See the `limit_total` argument for automatic paging option.  
   * @param limit_total The maximum number of items to return for the request.  If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum number specified.  Default: None (disabled).
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A ArtistPage object.
  */
  public async GetArtistsFollowed(
    entity_id: string,
    after: number | null = null, 
    limit: number | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<IArtistPage> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (after)
        serviceData['after'] = after;
      if (limit)
        serviceData['limit'] = limit;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_artists_followed',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IArtistPage;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about an audiobook's chapters.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param audiobook_id The Spotify ID for the audiobook (e.g. `74aydHJKgYz3AIq3jjBSv1`). If null, the currently playing audiobook uri id value is used.
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A ChapterPageSimplified object.
  */
  public async GetAudiobookChapters(
    entity_id: string,
    audiobook_id: string | null = null,
    limit: number | null = null,
    offset: number | null = null,
    market: string | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IChapterPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (audiobook_id)
        serviceData['audiobook_id'] = audiobook_id;
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_audiobook_chapters',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IChapterPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.available_markets = [];
            item.description = 'see html_description';
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the audiobooks owned or followed by the current Spotify user.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A AudiobookPageSimplified object.
  */
  public async GetAudiobookFavorites(
    entity_id: string,
    limit: number | null = null,
    offset: number | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<IAudiobookPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_audiobook_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IAudiobookPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.available_markets = [];
            item.description = 'see html_description';
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information for a single audiobook chapter identified by its unique Spotify ID.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param chapter_id The Spotify ID of the chapter.  If null, the currently playing episode uri id value is used. Example `3V0yw9UDrYAfkhAvTrvt9Y`.
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A `IChapter` object that contains the chapter details.
  */
  public async GetChapter(
    entity_id: string,
    chapter_id: string | undefined | null = null,
    market: string | undefined | null = null,
    trimResults: boolean = true,
  ): Promise<IChapter> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (chapter_id)
        serviceData['chapter_id'] = chapter_id;
      if (market)
        serviceData['market'] = market;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_chapter',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IChapter;

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if (responseObj != null) {
          responseObj.available_markets = [];
          responseObj.description = 'see html_description';
          responseObj.images = [];
          if (responseObj.audiobook) {
            responseObj.audiobook.available_markets = []
            responseObj.audiobook.images = []
            responseObj.audiobook.description = 'see html_description';
          }
        }
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information for a single episode identified by its unique Spotify ID.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param episode_id The Spotify ID of the episode.  If null, the currently playing episode uri id value is used. Example `1kWUud3vY5ij5r62zxpTRy`.
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A `IEpisode` object that contains the episode details.
  */
  public async GetEpisode(
    entity_id: string,
    episode_id: string | undefined | null = null,
    market: string | undefined | null = null,
    trimResults: boolean = true,
  ): Promise<IEpisode> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (episode_id)
        serviceData['episode_id'] = episode_id;
      if (market)
        serviceData['market'] = market;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_episode',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IEpisode;

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if (responseObj != null) {
          responseObj.description = 'see html_description';
          responseObj.images = [];
          if (responseObj.show) {
            responseObj.show.available_markets = []
            responseObj.show.images = []
            responseObj.show.description = 'see html_description';
          }
        }
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the episodes saved in the current Spotify user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param exclude_audiobooks True to exclude audiobook shows from the returned list, leaving only podcast shows; otherwise, False to include all results returned by the Spotify Web API. Default: True  
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IEpisodePageSaved object.
  */
  public async GetEpisodeFavorites(
    entity_id: string,
    limit: number | null = null,
    offset: number | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<IEpisodePageSaved> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_episode_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IEpisodePageSaved;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.episode.description = 'see html_description';
            item.episode.images = [];
            item.episode.show.available_markets = [];
            item.episode.show.description = 'see html_description';
            item.episode.show.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get the list of objects that make up the user's playback queue.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @returns A `PlayerQueueInfo` object.
  */
  public async GetPlayerQueueInfo(
    entity_id: string,
    trimResults: boolean = true,
  ): Promise<IPlayerQueueInfo> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_player_queue_info',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IPlayerQueueInfo;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.queue != null)) {
          if (responseObj.currently_playing != null) {
            if (responseObj.currently_playing_type == 'track') {
              const track = responseObj.currently_playing as ITrack;
              track.available_markets = [];
              if (track.album) {
                track.album.available_markets = []
                track.album.images = []
              }
            } else if (responseObj.currently_playing_type == 'episode') {
              const episode = responseObj.currently_playing as IEpisode;
              episode.description = "see html_description";
              if (episode.show) {
                episode.show.available_markets = []
                episode.show.description = "see html_description";
                episode.show.images = []
              }
            }
          }
          responseObj.queue.forEach(item => {
            if (item.type == 'track') {
              const track = item as ITrack;
              track.available_markets = [];
              if (track.album) {
                track.album.available_markets = []
                track.album.images = []
              }
            } else if (item.type == 'episode') {
              const episode = item as IEpisode;
              episode.description = "see html_description";
              if (episode.show) {
                episode.show.available_markets = []
                episode.show.description = "see html_description";
                episode.show.images = []
              }
            }
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get tracks from the current user's recently played tracks.
   * Note: Currently doesn't support podcast episodes.
   * 
   * The `after` and `before` arguments are based upon local time (not UTC time).  Recently
   * played item history uses a local timestamp, and NOT a UTC timestamp.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param after Returns all items after (but not including) this cursor position, which is a Unix timestamp in milliseconds.  If `after` is specified, `before` must not be specified.  Use with limit to get the next set of items.  Default: `0` (the first item).  
   * @param before Returns all items before (but not including) this cursor position, which is a Unix timestamp in milliseconds.  If `before` is specified, `after` must not be specified.  Use with limit to get the next set of items.  Default: `0` (the first item).  
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A PlayHistoryPage object.
  */
  public async GetPlayerRecentTracks(
    entity_id: string,
    limit: number | null = null,
    after: number | null = null,
    before: number | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IPlayHistoryPage> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (after)
        serviceData['after'] = after;
      if (before)
        serviceData['before'] = before;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_player_recent_tracks',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IPlayHistoryPage;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.track.available_markets = [];
            item.track.album.images = [];
            item.track.album.available_markets = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the playlists owned or followed by the current Spotify user.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A PlaylistPageSimplified object.
  */
  public async GetPlaylistFavorites(
    entity_id: string,
    limit: number | null = null,
    offset: number | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<IPlaylistPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_playlist_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IPlaylistPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the playlists owned or followed by the current Spotify user.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param playlist_id The Spotify ID of the playlist (e.g. 5v5ETK9WFXAnGQ3MRubKuE).  If null, the currently playing playlist uri id value is used.
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param fields Filters for the query; a comma-separated list of the fields to return. If omitted, all fields are returned. For example, specify 'items(track(name,uri))' to get just the playlist's track names and URIs.
   * @param additional_types A comma-separated list of item types that your client supports besides the default track type.  Valid types are 'track' and 'episode'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A PlaylistPageSimplified object.
  */
  public async GetPlaylistItems(
    entity_id: string,
    playlist_id: string | undefined | null = null,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    fields: string | undefined | null = null,
    additional_types: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IPlaylistPage> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (playlist_id)
        serviceData['playlist_id'] = playlist_id;
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (fields)
        serviceData['fields'] = fields;
      if (additional_types)
        serviceData['additional_types'] = additional_types;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_playlist_items',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IPlaylistPage;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(playlistTrack => {
            if (playlistTrack.track) {
              if (playlistTrack.track.available_markets) {
                playlistTrack.track.available_markets = [];
              }
              if (playlistTrack.track.album) {
                playlistTrack.track.album.images = []
                if (playlistTrack.track.album.available_markets) {
                  playlistTrack.track.album.available_markets = [];
                }
              }
            }
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get information about all available Spotify Connect player devices.
   * 
   * @param refresh True to return real-time information from the spotify zeroconf api and update the cache; otherwise, False to just return the cached value.
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Zeroconf API.  Default is true.
   * @returns A SpotifyConnectDevices object.
  */
  public async GetSpotifyConnectDevices(
    entity_id: string,
    refresh: boolean | null = null,
    sort_result: boolean | null = null,
  ): Promise<ISpotifyConnectDevices> {

    try {

      if (debuglog.enabled) {
        debuglog("%c GetSpotifyConnectDevices - retrieving device list from %s",
          "color: orange;",
          (refresh) ? "real-time query" : "internal device cache",
        );
      }

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (refresh)
        serviceData['refresh'] = refresh;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_spotify_connect_devices',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as ISpotifyConnectDevices;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // set image_url property based on device type.
      if ((responseObj != null) && (responseObj.Items != null)) {
        responseObj.Items.forEach(item => {
          // set image_url path using mdi icons for common sources.
          const sourceCompare = (item.Name || "").toLocaleLowerCase();
          if (sourceCompare.includes('web player (chrome)')) {
            item.image_url = getMdiIconImageUrl(mdiGoogleChrome);
          } else if (sourceCompare.includes('web player (microsoft edge)')) {
            item.image_url = getMdiIconImageUrl(mdiMicrosoftEdge);
          } else if (sourceCompare.includes('web player')) {
            item.image_url = getMdiIconImageUrl(mdiWeb);
          } else {
            item.image_url = getMdiIconImageUrl(mdiSpeaker);
          }
        })
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about a show's episodes.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param show_id The Spotify ID for the show (e.g. `6kAsbP8pxwaU2kPibKTuHE`). If null, the currently playing show uri id value is used.  
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A IEpisodePageSimplified object.
  */
  public async GetShowEpisodes(
    entity_id: string,
    show_id: string | null = null,
    limit: number | null = null,
    offset: number | null = null,
    market: string | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IEpisodePageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (show_id)
        serviceData['show_id'] = show_id;
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_show_episodes',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IEpisodePageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.description = 'see html_description';
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the shows owned or followed by the current Spotify user.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param exclude_audiobooks True to exclude audiobook shows from the returned list, leaving only podcast shows; otherwise, False to include all results returned by the Spotify Web API. Default: True  
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A IShowPageSaved object.
  */
  public async GetShowFavorites(
    entity_id: string,
    limit: number | null = null,
    offset: number | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    exclude_audiobooks: boolean | null = true,
    trimResults: boolean = true,
  ): Promise<IShowPageSaved> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;
      if (exclude_audiobooks)
        serviceData['exclude_audiobooks'] = exclude_audiobooks;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_show_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IShowPageSaved;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.show.available_markets = [];
            item.show.description = 'see html_description';
            item.show.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information for a single track identified by its unique Spotify ID.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param track_id The Spotify ID of the track.  If null, the currently playing track uri id value is used. Example `1kWUud3vY5ij5r62zxpTRy`.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A `ITrack` object that contains the track details.
  */
  public async GetTrack(
    entity_id: string,
    track_id: string | undefined | null = null,
    trimResults: boolean = true,
  ): Promise<ITrack> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (track_id)
        serviceData['track_id'] = track_id;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_track',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as ITrack;

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if (responseObj != null) {
          responseObj.available_markets = [];
          responseObj.album.available_markets = []
          responseObj.album.images = []
        }
      }

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get a list of the tracks saved in the current Spotify user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.  See the `limit_total` argument for automatic paging option.  
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param sort_result True to sort the items by name; otherwise, False to leave the items in the same order they were returned in by the Spotify Web API.  Default is true.
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A TrackPageSaved object.
  */
  public async GetTrackFavorites(
    entity_id: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    limit_total: number | null = null,
    sort_result: boolean | null = null,
    trimResults: boolean = true,
  ): Promise<ITrackPageSaved> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (limit_total)
        serviceData['limit_total'] = limit_total;
      if (sort_result)
        serviceData['sort_result'] = sort_result;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'get_track_favorites',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as ITrackPageSaved;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          responseObj.items.forEach(item => {
            item.track.available_markets = [];
            item.track.album.available_markets = [];
            item.track.album.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000

      return responseObj;

    }
    finally {
    }
  }


  /**
   * Start playing one or more tracks of the specified context on a Spotify Connect device.
   * 
   * @param entity_id 
   *    Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param context_uri 
   *    Spotify URI of the context to play.  
   *    Valid contexts are albums, artists & playlists.  
   *    Example: `spotify:album:6vc9OTcyd3hyzabCmsdnwE`. 
   * @param offset_uri 
   *    Indicates from what Uri in the context playback should start.  
   *    Only available when context_uri corresponds to an artist, album or playlist.  
   *    The offset_position argument will be used if this value is null.  
   *    For Sonos devices, this argument is ignored.  
   *    Default is null.  
   *    Example: `spotify:track:1301WleyT98MSxVHPZCA6M` start playing at the specified track Uri.  
   * @param offset_position
   *    Indicates from what position in the context playback should start.  
   *    The value is zero-based, and must be a positive number, or -1 to disable positioning.  
   *    Only available when context_uri corresponds to an album or playlist.  
   *    Default is `0`.  
   *    Example: `3`  start playing at track number 4.
   * @param position_ms
   *    The position in milliseconds to seek to; must be a positive number, or -1 to disable positioning.  
   *    Passing in a position that is greater than the length of the track will cause the 
   *    player to start playing the next track.  
   *    Default is `0`.  
   *    Example: `25000`  
   * @param device_id
   *    The name or id of the device this command is targeting.  
   *    If not supplied, the user's currently active device is the target.  
   *    Example: `0d1841b0976bae2a3a310dd74c0f3df354899bc8`
   * @param delay
   *    Time delay (in seconds) to wait AFTER issuing the command to the player.  
   *    This delay will give the spotify web api time to process the change before 
   *    another command is issued.  
   *    Default is 0.50; value range is 0 - 10.
  */
  public async PlayerMediaPlayContext(
    entity_id: string,
    context_uri: string,
    offset_uri: string | undefined | null = null,
    offset_position: number | null = null,
    position_ms: number | null = null,
    device_id: string | undefined | null = null,
    delay: number | null = null,
  ): Promise<void> {

    try {

      // validation.
      if (!context_uri)
        throw new Error("STPC0005 context_uri argument was not supplied to the PlayerMediaPlayContext service.")

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        context_uri: context_uri
      };

      // update service data parameters (with optional parameters).
      if (offset_uri)
        serviceData['offset_uri'] = offset_uri;
      if (offset_position)
        serviceData['offset_position'] = offset_position;
      if (position_ms)
        serviceData['position_ms'] = position_ms;
      if (device_id)
        serviceData['device_id'] = device_id;
      if (delay)
        serviceData['delay'] = delay;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'player_media_play_context',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Start playing one or more tracks of the specified context on a Spotify Connect device.
   * 
   * @param entity_id 
   *    Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param uris 
   *    A comma-delimited string of Spotify URIs to play; can be track or episode URIs.  
   *    Example: `spotify:track:4iV5W9uYEdYUVa79Axb7Rh,spotify:episode:512ojhOuo1ktJprKbVcKyQ`.  
   *    A maximum of 50 items can be added in one request.
   * @param position_ms
   *    The position in milliseconds to seek to; must be a positive number, or -1 to disable positioning.  
   *    Passing in a position that is greater than the length of the track will cause the 
   *    player to start playing the next track.  
   *    Default is `0`.  
   *    Example: `25000`  
   * @param device_id
   *    The name or id of the device this command is targeting.  
   *    If not supplied, the user's currently active device is the target.  
   *    Example: `Office`, `0d1841b0976bae2a3a310dd74c0f3df354899bc8`
   * @param delay
   *    Time delay (in seconds) to wait AFTER issuing the command to the player.  
   *    This delay will give the spotify web api time to process the change before 
   *    another command is issued.  
   *    Default is 0.50; value range is 0 - 10.
  */
  public async PlayerMediaPlayTracks(
    entity_id: string,
    uris: string,
    position_ms: number | null = null,
    device_id: string | undefined | null = null,
    delay: number | null = null,
  ): Promise<void> {

    try {

      // validation.
      if (!uris)
        throw new Error("STPC0005 uris argument was not supplied to the PlayerMediaPlayTracks service.")
      if (position_ms == null)
        position_ms = 0;

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        uris: uris
      };

      // update service data parameters (with optional parameters).
      if (position_ms)
        serviceData['position_ms'] = position_ms;
      if (device_id)
        serviceData['device_id'] = device_id;
      if (delay)
        serviceData['delay'] = delay;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'player_media_play_tracks',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Remove one or more albums from the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the albums.  If null, the currently playing track album uri id value is used.
  */
  public async RemoveAlbumFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'remove_album_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Remove one or more audiobooks from the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the audiobooks.  If null, the currently playing audiobook uri id value is used.
  */
  public async RemoveAudiobookFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'remove_audiobook_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Remove one or more episodes from the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the episodes.  If null, the currently playing episode uri id value is used.
  */
  public async RemoveEpisodeFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'remove_episode_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Remove one or more shows from the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the shows.  If null, the currently playing show uri id value is used.
  */
  public async RemoveShowFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'remove_show_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Remove one or more tracks from the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the tracks.  If null, the currently playing track uri id value is used.
  */
  public async RemoveTrackFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'remove_track_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Save one or more albums to the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the albums.  If null, the currently playing track album uri id value is used.
  */
  public async SaveAlbumFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'save_album_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Save one or more audiobooks to the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the audiobooks.  If null, the currently playing audiobook uri id value is used.
  */
  public async SaveAudiobookFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'save_audiobook_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Save one or more episodes to the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the episodes.  If null, the currently playing episode uri id value is used.
  */
  public async SaveEpisodeFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'save_episode_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Save one or more shows to the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the shows.  If null, the currently playing show uri id value is used.
  */
  public async SaveShowFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'save_show_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Save one or more tracks to the current user's 'Your Library'.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the tracks.  If null, the currently playing track uri id value is used.
  */
  public async SaveTrackFavorites(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'save_track_favorites',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about matching context criteria.
   * 
   * @param context Contexts to search for.
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @returns A AlbumPageSaved object.
  */
  public async Search(
    searchMediaType: SearchMediaTypes.ALBUMS | SearchMediaTypes.ARTISTS | SearchMediaTypes.AUDIOBOOKS | SearchMediaTypes.EPISODES |
      SearchMediaTypes.PLAYLISTS | SearchMediaTypes.SHOWS | SearchMediaTypes.TRACKS,
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
  ): Promise<IAlbumPageSimplified | IArtistPage | IAudiobookPageSimplified | IEpisodePageSimplified | IPlaylistPageSimplified | IShowPageSimplified | ITrackPage> {

    try {

      // execute based on search media type.
      if (searchMediaType == SearchMediaTypes.ALBUMS) {
        return await this.SearchAlbums(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else if (searchMediaType == SearchMediaTypes.ARTISTS) {
        return await this.SearchArtists(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else if (searchMediaType == SearchMediaTypes.AUDIOBOOKS) {
        return await this.SearchAudiobooks(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else if (searchMediaType == SearchMediaTypes.EPISODES) {
        return await this.SearchEpisodes(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else if (searchMediaType == SearchMediaTypes.PLAYLISTS) {
        return await this.SearchPlaylists(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else if (searchMediaType == SearchMediaTypes.SHOWS) {
        return await this.SearchShows(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else if (searchMediaType == SearchMediaTypes.TRACKS) {
        return await this.SearchTracks(entity_id, criteria, limit, offset, market, include_external, limit_total)
      } else {
        throw new Error("searchMediaType was not recognized: \"" + searchMediaType + "\".");
      }

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about albums that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns A AlbumPageSaved object.
  */
  public async SearchAlbums(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IAlbumPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_albums',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IAlbumPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as IAlbumSimplified[]).forEach(item => {
            item.images = [];
            item.available_markets = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about artists that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IArtistPage object.
  */
  public async SearchArtists(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IArtistPage> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_artists',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IArtistPage;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as IArtist[]).forEach(item => {
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about audiobooks that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IAudiobookPageSimplified object.
  */
  public async SearchAudiobooks(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IAudiobookPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_audiobooks',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IAudiobookPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as IAudiobookSimplified[]).forEach(item => {
            item.images = [];
            item.available_markets = [];
            item.description = "see html_description";
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about episodes that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IEpisodePageSimplified object.
  */
  public async SearchEpisodes(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IEpisodePageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_episodes',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IEpisodePageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as IEpisodeSimplified[]).forEach(item => {
            item.images = [];
            item.description = "see html_description";
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about playlists that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IArtistPage object.
  */
  public async SearchPlaylists(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IPlaylistPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_playlists',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IPlaylistPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as IPlaylistSimplified[]).forEach(item => {
            item.images = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about shows that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IShowPageSimplified object.
  */
  public async SearchShows(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<IShowPageSimplified> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_shows',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as IShowPageSimplified;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as IShowSimplified[]).forEach(item => {
            item.images = [];
            item.available_markets = [];
            item.description = "see html_description";
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Get Spotify catalog information about tracks that match a keyword string.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param criteria Your search query. 
   * @param limit The maximum number of items to return in a page of items.  Default: 20, Range: 1 to 50.
   * @param offset The index of the first item to return.  Use with limit to get the next set of items.  Default: 0(the first item).
   * @param market An ISO 3166-1 alpha-2 country code. If a country code is specified, only content that is available in that market will be returned.  If a valid user access token is specified in the request header, the country associated with the user account will take priority over this parameter.  Example = 'ES'.
   * @param include_external If "audio" is specified it signals that the client can play externally hosted audio content, and marks the content as playable in the response. By default externally hosted audio content is marked as unplayable in the response.  Allowed values: "audio"
   * @param limit_total If specified, this argument overrides the limit and offset argument values and paging is automatically used to retrieve all available items up to the maximum count specified.  Default: None(disabled)
   * @param trimResults True to trim certain fields of the output results that are not required and to conserve memory; otherwise, False to return all fields that were returned in by the Spotify Web API.
   * @returns An IArtistPage object.
  */
  public async SearchTracks(
    entity_id: string,
    criteria: string,
    limit: number | null = null,
    offset: number | null = null,
    market: string | undefined | null = null,
    include_external: string | undefined | null = null,
    limit_total: number | null = null,
    trimResults: boolean = true,
  ): Promise<ITrackPage> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
        criteria: criteria,
      };

      // update service data parameters (with optional parameters).
      if (limit)
        serviceData['limit'] = limit;
      if (offset)
        serviceData['offset'] = offset;
      if (market)
        serviceData['market'] = market;
      if (include_external)
        serviceData['include_external'] = include_external;
      if (limit_total)
        serviceData['limit_total'] = limit_total;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'search_tracks',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // get the "result" portion of the response, and convert it to a type.
      const responseResult = this._GetJsonStringResult(response);
      const responseObj = JSON.parse(responseResult) as ITrackPage;

      //// get the "user_profile" portion of the response, and convert it to a type.
      //this._GetJsonStringUserProfile(response);

      // omit some data from the results, as it's not necessary and conserves memory.
      if (trimResults) {
        if ((responseObj != null) && (responseObj.items != null)) {
          (responseObj.items as ITrack[]).forEach(item => {
            if (item.album) {
              item.album.images = [];
              item.album.available_markets = [];
            }
            item.available_markets = [];
          })
        }
      }

      // set the lastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.lastUpdatedOn = Date.now() / 1000
      return responseObj;

    }
    finally {
    }
  }


  /**
   * Remove the current user as a follower of one or more artists.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param ids A comma-separated list (50 max) of the Spotify IDs for the artists.  If null, the currently playing track artist uri id value is used.
  */
  public async UnfollowArtists(
    entity_id: string,
    ids: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (ids)
        serviceData['ids'] = ids;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'unfollow_artists',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /**
   * Remove the current user as a follower of one or more playlists.
   * 
   * @param entity_id Entity ID of the SpotifyPlus device that will process the request (e.g. "media_player.spotifyplus_john_smith").
   * @param playlist_id The Spotify ID of the playlist (e.g. `3cEYpjA9oz9GiPac4AsH4n`). If null, the currently playing playlist uri id value is used.
  */
  public async UnfollowPlaylist(
    entity_id: string,
    playlist_id: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: entity_id,
      };

      // update service data parameters (with optional parameters).
      if (playlist_id)
        serviceData['playlist_id'] = playlist_id;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SPOTIFYPLUS,
        service: 'unfollow_playlist',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    }
    finally {
    }
  }


  /** ======================================================================================
   * The following are common helper methods for SpotifyPlus Card support.
   * ====================================================================================== **/

  /**
   * Calls the SpotifyPlusService PlayerMediaPlayX method to play media.
   * 
   * @param player SpotifyPlus media player to direct the request to.
   * @param mediaItem Media Browser item that contains media content details to play.
   */
  public async Card_PlayMediaBrowserItem(
    player: MediaPlayer,
    mediaItem: any,
  ): Promise<void> {

    // validations.
    if (!player) {
      throw new Error("Media player argument was not supplied to the PlayMediaBrowserItem service.")
    }
    if (!mediaItem) {
      throw new Error("Media browser item argument was not supplied to the PlayMediaBrowserItem service.");
    }

    try {

      // get item type from uri; we cannot use `mediaItem.type` here, as the value
      // will not be the same as the uri type for some media items (e.g. chapter).
      const uriType = getTypeFromSpotifyUri(mediaItem.uri) || "";

      if (debuglog.enabled) {
        debuglog("Card_PlayMediaBrowserItem - play media item\n- player.id = %s\n- mediaItem.uri = %s\n- uriType = %s",
          JSON.stringify(player.id),
          JSON.stringify(mediaItem.uri),
          JSON.stringify(uriType),
        );
      }

      if (['album', 'artist', 'playlist', 'show', 'audiobook', 'podcast'].indexOf(uriType) > -1) {

        // play context.
        const device_id = player.attributes.source || null;
        await this.PlayerMediaPlayContext(player.id, mediaItem.uri || '', null, null, null, device_id, null);

      } else if (['track', 'episode', 'chapter'].indexOf(uriType) > -1) {

        // play track / episode / chapter.
        const device_id = player.attributes.source || null;
        await this.PlayerMediaPlayTracks(player.id, mediaItem.uri || '', null, device_id, null);

      } else {

        throw new Error("unknown media type \"" + uriType + "\".");
      }
    }
    finally {
    }
  }
}


/**
* Gets the Id portion (e.g. "26c0zVyOv1lzfYpBXdh1zC") of a valid Spotify URI 
* value (e.g. "spotify:episode:26c0zVyOv1lzfYpBXdh1zC").
* 
* @param uri String value that contains a Spotify URI value (e.g. "spotify:episode:26c0zVyOv1lzfYpBXdh1zC").
* @returns Id portion of the URI value (e.g. "26c0zVyOv1lzfYpBXdh1zC") if found; otherwise, undefined.
*/
export function getIdFromSpotifyUri(uri: string | undefined | null): string | undefined | null {
  let result = uri;
  if (uri) {
    const idx = uri.lastIndexOf(':');
    if (idx > -1) {
      result = uri.substring(idx + 1)
    }
  }
  return result;
}


/**
* Gets the Type portion (e.g. "episode") of a valid Spotify URI 
* value (e.g. "spotify:episode:26c0zVyOv1lzfYpBXdh1zC").
* 
* @param uri String value that contains a Spotify URI value (e.g. "spotify:episode:26c0zVyOv1lzfYpBXdh1zC").
* @returns Type portion of the URI value (e.g. "episode") if found; otherwise, undefined.
*/
export function getTypeFromSpotifyUri(uri: string | undefined | null): string | undefined | null {
  let result = uri;
  if (uri) {
    const idx = uri.indexOf(':');
    if (idx > -1) {
      const idxe = uri.lastIndexOf(':');
      if (idxe > -1) {
        result = uri.substring(idx + 1, idxe)
      }
    }
  }
  return result;
}
